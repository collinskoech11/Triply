"use strict";var e=require("react"),t=require("react-hook-form"),n=require("zod"),r=require("@hookform/resolvers/zod");const o="_rtf_id";function i(e){return o in e._def}function s(e,t,n,r){return new(n||(n=Promise))((function(o,i){function s(e){try{d(r.next(e))}catch(e){i(e)}}function a(e){try{d(r.throw(e))}catch(e){i(e)}}function d(e){var t;e.done?o(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}d((r=r.apply(e,t||[])).next())}))}const a=[n.z.ZodFirstPartyTypeKind.ZodOptional,n.z.ZodFirstPartyTypeKind.ZodNullable,n.z.ZodFirstPartyTypeKind.ZodBranded,n.z.ZodFirstPartyTypeKind.ZodDefault,n.z.ZodFirstPartyTypeKind.ZodLazy],d=new Set(a);function u(e){throw new Error("[assertNever] Unexpected value: "+e)}function c(e){return d.has(e)}function l(e){let t=e,r=null;for(;c(t._def.typeName);)switch(i(t)&&(r=t._def[o]),t._def.typeName){case n.z.ZodFirstPartyTypeKind.ZodOptional:t=t._def.innerType;break;case n.z.ZodFirstPartyTypeKind.ZodBranded:t=t._def.type;break;case n.z.ZodFirstPartyTypeKind.ZodNullable:case n.z.ZodFirstPartyTypeKind.ZodDefault:t=t._def.innerType;break;case n.z.ZodFirstPartyTypeKind.ZodLazy:t=t._def.getter();break;default:u(t._def.typeName)}let s=null;return i(t)&&(s=t._def[o]),{type:t,[o]:s||r}}function f(e){return e._def.typeName===n.ZodFirstPartyTypeKind.ZodEffects?e._def.schema:e}function p(e,t,r){let{type:o,_rtf_id:i}=l(e),{type:s,_rtf_id:a}=l(t);if(r.has(o)&&r.has(s))return!0;if(r.add(o),r.add(s),i||a)return i===a;if(o._def.typeName!==s._def.typeName)return!1;if(o._def.typeName===n.ZodFirstPartyTypeKind.ZodArray&&s._def.typeName===n.ZodFirstPartyTypeKind.ZodArray)return!!p(o._def.type,s._def.type,r);if(o._def.typeName===n.ZodFirstPartyTypeKind.ZodSet&&s._def.typeName===n.ZodFirstPartyTypeKind.ZodSet)return!!p(o._def.valueType,s._def.valueType,r);if(o._def.typeName===n.ZodFirstPartyTypeKind.ZodMap&&s._def.typeName===n.ZodFirstPartyTypeKind.ZodMap)return!(!p(o._def.keyType,s._def.keyType,r)||!p(o._def.valueType,s._def.valueType,r));if(o._def.typeName===n.ZodFirstPartyTypeKind.ZodRecord&&s._def.typeName===n.ZodFirstPartyTypeKind.ZodRecord)return!!p(o._def.valueType,s._def.valueType,r);if(o._def.typeName===n.ZodFirstPartyTypeKind.ZodTuple&&s._def.typeName===n.ZodFirstPartyTypeKind.ZodTuple){const e=o._def.items,t=s._def.items;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(!p(e[n],t[n],r))return!1;return!0}if(o._def.typeName===n.ZodFirstPartyTypeKind.ZodObject&&s._def.typeName===n.ZodFirstPartyTypeKind.ZodObject){const e=o._def.shape(),t=s._def.shape();if(!e||!t)return!e&&!t;const n=Object.keys(e),i=Object.keys(t),a=new Set(n),u=new Set(i);for(const e of i)if(!a.has(e))return!1;for(const e of n)if(!u.has(e))return!1;for(var d of n){const n=e[d],o=t[d];if(!o||!p(n,o,r))return!1}}return!0}function m(e,t){return p(e,t,new Set)}function y(e,t){return e._def.typeName===n.ZodFirstPartyTypeKind[t]}const h=" // ";function b(e){if(!e)return;const[t,...n]=e.split(h).map((e=>e.trim())),r=n.join(h);return{label:t,placeholder:r||void 0}}function v(e){if(e._def.typeName===n.z.ZodFirstPartyTypeKind.ZodEnum)return e._def.values}const g=n.z.object({}),_=n.z.object({message:n.z.string(),type:n.z.string()});function F(e){if(!function(e){return g.safeParse(e).success}(e))return;if(function(e){return _.safeParse(e).success}(e))return{errorMessage:e.message};const t={};for(const n in e)t[n]=F(e[n]);return t}const T=e.createContext(null);function Z({name:t,control:n,children:r,label:o,placeholder:i,enumValues:s,zodType:a,addToCoerceUndefined:d,removeFromCoerceUndefined:u}){return e.createElement(T.Provider,{value:{control:n,name:t,label:o,placeholder:i,enumValues:s,zodType:a,addToCoerceUndefined:d,removeFromCoerceUndefined:u}},r)}function O(){const t=e.useContext(T);return null==t?void 0:t.name}function P(t){const n=e.useContext(T);if(!n)throw Error(`${t} must be called from within a FieldContextProvider... if you use this hook, the component must be rendered by @ts-react/form.`);return n}function j(e,t){return`No ${e} found when calling ${t}. Either pass it as a prop or pass it using the zod .describe() syntax.`}function E(e){const{type:t,_rtf_id:n}=l(e);return{type:t,zodType:e,uniqueId:null!=n?n:void 0,isOptional:e.isOptional(),isNullable:e.isNullable(),defaultValue:function(){const t=e._def;if(n=t,Boolean(n&&"object"==typeof n&&"defaultValue"in n&&"function"==typeof n.defaultValue)){return t.defaultValue()}var n}()}}function w(e){const{zodType:t,label:n,placeholder:r}=P(e),o=E(t);return Object.assign(Object.assign({},o),{label:n,placeholder:r})}function x(e,t,n){const r=w(n);const o=function(){const{type:t}=r;if("ZodArray"!==e&&y(t,"ZodArray")){return t.element}return t}();if(!y(o,e))throw new Error(function(e,{expectedType:t,receivedType:n}){return`Make sure that the '${e}' hook is being called inside of a custom form component which matches the correct type.\n  The expected type is '${t}' but the received type was '${n}'`}(n,{expectedType:e,receivedType:o._def.typeName}));return Object.assign(Object.assign({},function(e,t){return Object.entries(t).reduce(((t,[n])=>{const r=e[n];return"string"!=typeof r&&"number"!=typeof r&&"boolean"!=typeof r&&"bigint"!=typeof r&&void 0!==r||(t[n]=r),t}),{})}(o,t)),r)}const N={enum:!1,useEnum:!1,duplicateSchema:!1};function C(){var e;N.duplicateSchema||(N.duplicateSchema=!0,e="Found duplicate zod schema in zod-component mapping. Each zod type in the mapping must be unique, if you need to map multiple of the same types to different schemas use createUniqueFieldSchema.",console.warn(`@ts-react/form: ${e}`))}const z=[["name","name"],["control","control"],["enumValues","enumValues"]];function S(n,a){var d;const u=n.map((e=>e[0]));!function(e){var t=e.flatMap(((t,n)=>e.slice(n+1).map((e=>[t,e]))));for(const[e,n]of t)m(e,n)&&C()}(u),function(e){let t=new Set;for(const n of e)if(i(n)){if(t.has(n._def[o]))throw new Error(`Duplicate id passed to createFieldSchema: ${n._def[o]}. Ensure that each id is only being used once and that createFieldSchema is only called at the top level.`);t.add(n._def[o])}}(u);const c=function(e){const t={};for(const[n,r]of e)t[n]=r;return t}(null!==(d=null==a?void 0:a.propsMap)&&void 0!==d?d:z),p=(null==a?void 0:a.FormComponent)||"form";function y({schema:t,props:r,schemaKey:o,form:{control:i,getValues:s},namePrefix:a,submitter:d}){const u=[a,g(o)].filter(Boolean).join("number"==typeof o?"":".");return function t(r,o,s,a){var u,p,y,h,g;const _=f(r),F=function(e,t){for(const n of t)if(m(e,n[0]))return n[1]}(_,n);if(!F){if(U(_)){const e=_._def.shape();return Object.entries(e).reduce(((e,[n,r])=>(e[n]=t(r,o&&o[n]?o[n]:void 0,`${s}.${n}`,a&&a[n]),e)),{})}if(k(_))return(null!==(u=a)&&void 0!==u?u:[]).map(((e,n)=>t(_.element,o,`${s}[${n}]`,e)));throw new Error((T=s.toString(),`No matching zod schema for type \`${_._def.typeName}\` found in mapping for property \`${T}\`. Make sure there's a matching zod schema for every property in your schema.`))}var T;const O=function(e){const t=l(e),n=function(e){let t=e;if(t._def.description)return t._def.description;for(;"unwrap"in t;)if(t=t.unwrap(),t._def.description)return t._def.description}(e);return{description:b(n),enumValues:v(t.type)}}(_),{beforeElement:P,afterElement:j}=null!=o?o:{},E=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},c.name&&{[c.name]:s}),c.control&&{[c.control]:i}),c.enumValues&&{[c.enumValues]:O.enumValues}),c.descriptionLabel&&{[c.descriptionLabel]:null===(p=O.description)||void 0===p?void 0:p.label}),c.descriptionPlaceholder&&{[c.descriptionPlaceholder]:null===(y=O.description)||void 0===y?void 0:y.placeholder}),o),w=null===(h=O.description)||void 0===h?void 0:h.label,x=null===(g=O.description)||void 0===g?void 0:g.placeholder;return e.createElement(e.Fragment,{key:s},P,e.createElement(Z,{control:i,name:s,label:w,zodType:_,placeholder:x,enumValues:O.enumValues,addToCoerceUndefined:d.addToCoerceUndefined,removeFromCoerceUndefined:d.removeFromCoerceUndefined},e.createElement(F,Object.assign({key:s},E))),j)}(t,r,u,s()[u])}function h({schema:n,props:r,children:o,schemaKey:i}){const s=t.useFormContext(),a=O(),d=V();const u=function(e,t){const n=f(e)._def.shape();return Object.entries(n).reduce(((e,[n,r])=>{const o=n.toString(),u=t&&t[n]?t[n]:void 0;return e[o]=y({form:s,schema:r,props:u,namePrefix:a,submitter:d,schemaKey:[g(i),o].filter(Boolean).join(".")}),e}),{})}(n,r);return e.createElement(e.Fragment,null,e.createElement(_,{renderedFields:u,customChildRenderProp:o}))}function g(e){return"number"==typeof e?`[${e}]`:e}function _({customChildRenderProp:t,renderedFields:n}){return e.createElement(e.Fragment,null,t?t(n):I(n))}return[function({schema:n,onSubmit:o,props:i,formProps:a,defaultValues:d,renderAfter:u,renderBefore:c,form:l,children:f}){if(!!e.useRef(l).current!=!!l)throw new Error("useFormResult prop changed - its value shouldn't changed during the lifetime of the component.");const m=r.zodResolver(n),y=(()=>{if(l)return l;return t.useForm({resolver:m,defaultValues:d})})();e.useEffect((()=>{l&&d&&l.reset(d)}),[]);const{handleSubmit:b,setError:v}=y,g=function({resolver:t,onSubmit:n,setError:r}){const o=e.useRef(new Set);function i(e){o.current.add(e)}function a(e){o.current.delete(e)}function d(e){const t=Object.assign({},e);for(const e of o.current)delete t[e];return t}function u(e){return t(d(e),{},{}).then((e=>s(this,void 0,void 0,(function*(){const t=Object.keys(e.errors);if(t.length)for(const n of t)r(n,e.errors[n]);else yield n(e.values)}))))}return{submit:u,removeUndefined:d,removeFromCoerceUndefined:a,addToCoerceUndefined:i}}({resolver:m,onSubmit:o,setError:v}),_=b(g.submit);return e.createElement(t.FormProvider,Object.assign({},y),e.createElement(D,Object.assign({},g),e.createElement(p,Object.assign({},a,{onSubmit:_}),null==u?void 0:u({submit:_}),e.createElement(h,Object.assign({},{schema:n,props:i,children:f})),null==c?void 0:c({submit:_}))))},h,function(n){return e.createElement(e.Fragment,null,I(y(Object.assign(Object.assign({},n),{props:n.props,form:t.useFormContext(),namePrefix:O(),submitter:V()}))))}]}const K=e.createContext(null);function V(){const t=e.useContext(K);if(!t)throw new Error("useSubmitterContext must be used within a SubmitterContextProvider");return t}function D(t){var{children:n}=t,r=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(r=Object.getOwnPropertySymbols(e);o<r.length;o++)t.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(e,r[o])&&(n[r[o]]=e[r[o]])}return n}(t,["children"]);return e.createElement(K.Provider,{value:r,children:n})}const U=e=>e._def.typeName===n.ZodFirstPartyTypeKind.ZodObject,k=e=>e._def.typeName===n.ZodFirstPartyTypeKind.ZodArray;function I(t){return Array.isArray(t)?t.flatMap((e=>I(e))):"object"!=typeof t||null===t||e.isValidElement(t)?[t]:Object.values(t).reduce(((e,t)=>e.concat(I(t))),[])}exports.createTsForm=function(e,t){return S(e,t)[0]},exports.createTsFormAndFragment=S,exports.createUniqueFieldSchema=function(e,t){return function(e,t){for(const n in t)e._def[n]=t[n];return e}(e.brand(),{[o]:t})},exports.useDateFieldInfo=function(){const e=x("ZodDate",{description:!0,maxDate:!0,minDate:!0},"useDateFieldInfo");return Object.assign(Object.assign({},e),{maxDate:e.type.maxDate,minDate:e.type.minDate})},exports.useDescription=function(){const{label:e,placeholder:t}=P("useReqDescription");return{label:e,placeholder:t}},exports.useEnumValues=function(){const{enumValues:e}=P("useEnumValues");if(!e)throw new Error("Enum values not passed. Any component that calls useEnumValues should be rendered from an '.enum()' zod field.");return e},exports.useFieldInfo=function(){return w("useFieldInfo")},exports.useMaybeFieldName=O,exports.useNumberFieldInfo=function(){return x("ZodNumber",{description:!0,isFinite:!0,isInt:!0,maxValue:!0,minValue:!0},"useNumberFieldInfo")},exports.useReqDescription=function(){const{label:e,placeholder:t}=P("useReqDescription");if(!e)throw new Error(j("label","useReqDescription"));if(!t)throw new Error(j("placeholder","useReqDescription"));return{label:e,placeholder:t}},exports.useStringFieldInfo=function(){return x("ZodString",{description:!0,isCUID:!0,isCUID2:!0,isDatetime:!0,isEmail:!0,isEmoji:!0,isIP:!0,isULID:!0,isURL:!0,isUUID:!0,maxLength:!0,minLength:!0},"useStringFieldInfo")},exports.useTsController=function(){const n=P("useTsController"),r=t.useController(n),{fieldState:o,field:{onChange:i,value:s}}=r,[a,d]=e.useState(!1);return e.useEffect((()=>{s&&a&&(d(!1),n.removeFromCoerceUndefined(n.name))}),[s]),Object.assign(Object.assign({},r),{error:F(o.error),field:Object.assign(Object.assign({},r.field),{value:a?void 0:r.field.value,onChange:function(e){void 0===e?(d(!0),n.addToCoerceUndefined(n.name)):(d(!1),n.removeFromCoerceUndefined(n.name),i(e))}})})};
